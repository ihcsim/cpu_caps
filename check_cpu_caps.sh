#!/bin/bash

set -e

source ./obsolete.sh

KUBEVIRT_NAMESPACE=${KUBEVIRT_NAMESPACE:-harvester-system}
DEBUGGER_TTL_SECONDS=3600

while getopts "hi:" opt; do
  case $opt in
  i)
    virt_launcher_custom_image_path="${OPTARG}"
    ;;
  h)
    echo "Usage: $0 [-i virt-handler-custom-image-path]"
    exit 0
    ;;
  *)
    echo "Usage: $0 [-i virt-handler-custom-image-path]"
    exit 1
    ;;
  esac
done

now=$(date "+%Y%m%d-%H%M%S")
src_dir=$(dirname $(readlink -f -- "${BASH_SOURCE[0]}"))
virt_handlers=($(kubectl -n "${KUBEVIRT_NAMESPACE}" get po \
  -lkubevirt.io=virt-handler \
  --no-headers \
  -ojsonpath='{range .items[*]}{.metadata.name},{.spec.nodeName}{"\n"}{end}'))
declare -a tmp_out_paths

# collect the cpu capabilities .xml files from the host using virt-launcher.
# the image used by the in-cluster virt-handler daemonset is used as the default
# version.
# if the ${virt_launcher_custom_image_path} variable is specified, it will be added
# to the discovery iterations.
function cpu_caps() {
  declare -a image_versions
  image_versions+=("$(kubectl -n "${KUBEVIRT_NAMESPACE}" get ds virt-handler -ojsonpath='{.spec.template.spec.initContainers[?(@.name=="virt-launcher")].image}')")
  if [ ! -z "${virt_launcher_custom_image_path}" ]; then
    image_versions+=("${virt_launcher_custom_image_path}")
  fi

  for version in "${image_versions[@]}"; do
    echo "‚û°Ô∏è version: ${version}"
    for virt_handler in "${virt_handlers[@]}"; do
      run_debugger "${virt_handler}" "${version}"
    done
  done
}

# start an ephemeral container to collect the cpu capabilities .xml files
# generated by virt-launcher. the container references the in-container
# /var/lib/kubevirt-node-labeller folder, not the one on the host.
function run_debugger() {
  local virt_handler="$1"
  local virt_launcher_image="$2"
  local pod_name=$(echo "${virt_handler}" | cut -d',' -f1)
  local node_name=$(echo "${virt_handler}" | cut -d',' -f2)
  local debugger_name=debug-"$(date '+%Y%m%d-%H%M%S')"
  echo "  ‚è≥ checking pod ${KUBEVIRT_NAMESPACE}/${pod_name}..."
  kubectl -n "${KUBEVIRT_NAMESPACE}" debug \
    --image="${virt_launcher_image}" \
    --container "${debugger_name}" \
    --profile=general \
    --custom="${src_dir}"/scc.yaml \
    "${pod_name}" -- /bin/bash -c "set -e; mkdir -p /var/lib/kubevirt-node-labeller; node-labeller.sh; virsh version > /var/lib/kubevirt-node-labeller/.version; touch /var/lib/kubevirt-node-labeller/.done; sleep ${DEBUGGER_TTL_SECONDS}"

  set +e
  echo "     running debugger ${pod_name}/${debugger_name}..."

  while true; do
    if kubectl -n "${KUBEVIRT_NAMESPACE}" exec -c "${debugger_name}" "${pod_name}" -- ls -al /var/lib/kubevirt-node-labeller/.done >/dev/null 2>&1; then
      break
    fi
    sleep 5
  done
  set -e

  local image_tag=$(echo "${virt_launcher_image}" | cut -d":" -f2)
  local out_path="./out-${now}/${node_name}/${image_tag}"
  kubectl -n "${KUBEVIRT_NAMESPACE}" cp -c "${debugger_name}" "${pod_name}":/var/lib/kubevirt-node-labeller "${out_path}"
  tmp_out_paths+=("${out_path}")
}

function tarball() {
  tar -czf ./out-"${now}".tar.gz ./out-"${now}"
  rm -rf ./out-"${now}"
}

# generate a yaml report file based on the .xml files gathered by the debugger
function report() {
  echo "‚öôÔ∏è generating report summary..."
  declare -A report
  for out_path in "${tmp_out_paths[@]}"; do
    local node_name=$(echo "${out_path}" | cut -d'/' -f3)
    local image_tag=$(echo "${out_path}" | cut -d'/' -f4)

    local host_cpu_model_info=($(get_host_cpu_model_info "${out_path}"))
    local host_cpu_model="${host_cpu_model_info[0]}"
    local vendor="${host_cpu_model_info[1]}"

    local host_cpu_required_features="$(get_host_cpu_required_features "${out_path}")"
    local format_host_cpu_required_features=$(echo "- ${host_cpu_required_features}" | sed -z 's/\n/\n      - /g' | head -n -1)

    local supported_models=$(get_supported_models "${out_path}")
    local format_supported_models=$(echo "${supported_models}" | sed -z 's/ /\n    - /g' | head -n -1)
    format_supported_models=$(echo "- ${format_supported_models}")

    local supported_features=$(get_supported_features "${out_path}")
    local format_supported_features=$(echo "- ${supported_features}" | sed -z 's/\n/\n    - /g' | head -n -1)

    local virsh_meta=$(get_virsh_meta "${out_path}")
    local format_virsh_meta=$(echo "${virsh_meta}" | sed -z 's/\n/\n      /g' | head -n -2)

    local report_entry="  - virt_launcher: ${image_tag}
    host_cpu_model:
      name: ${host_cpu_model}
      vendor: ${vendor}
      required_features:
      ${format_host_cpu_required_features}
    supported_models:
    ${format_supported_models}
    supported_features:
    ${format_supported_features}
    virsh_version: |
      ${format_virsh_meta}"

    if [ -z "${report[${node_name}]}" ]; then
      report[${node_name}]="  ${node_name}:\n${report_entry}"
    else
      report[${node_name}]="${report[${node_name}]}\n${report_entry}"
    fi
  done

  echo "nodes:" >./out-"${now}"/report.yaml
  for node in "${!report[@]}"; do
    echo -e "${report[${node}]}" >>./out-"${now}"/report.yaml
  done
  echo "  üìù output saved to ./out-${now}.tar.gz"
}

# see https://github.com/kubevirt/kubevirt/blob/ef9e136df7e676b408fb8b38dffbdf91be491601/pkg/virt-handler/node-labeller/cpu_plugin.go#L98-L112
function get_host_cpu_model_info() {
  out_path="$1"
  local host_cpu_model=$(yq -oy ${out_path}/virsh_domcapabilities.xml | yq '.domainCapabilities.cpu.mode.[] | select(.+@name == "host-model").model.+content')
  local vendor=$(yq -oy ${out_path}/virsh_domcapabilities.xml | yq '.domainCapabilities.cpu.mode.[] | select(.+@name == "host-model").vendor')
  echo "${host_cpu_model} ${vendor}"
}

# see https://github.com/kubevirt/kubevirt/blob/ef9e136df7e676b408fb8b38dffbdf91be491601/pkg/virt-handler/node-labeller/cpu_plugin.go#L114-L118
function get_host_cpu_required_features() {
  out_path="$1"
  local required_features=$(yq -oy ${out_path}/virsh_domcapabilities.xml | yq '.domainCapabilities.cpu.mode.[] | select(.+@name == "host-model").feature.[] | select(.+@policy == "require").+@name')
  echo "${required_features}"
}

# see https://github.com/kubevirt/kubevirt/blob/ef9e136df7e676b408fb8b38dffbdf91be491601/pkg/virt-handler/node-labeller/cpu_plugin.go#L121-L130
# and https://github.com/kubevirt/kubevirt/blob/ef9e136df7e676b408fb8b38dffbdf91be491601/pkg/virt-handler/node-labeller/cpu_plugin.go#L60-L62
function get_supported_models() {
  out_path="$1"
  local usable_models=($(yq -oy ${out_path}/virsh_domcapabilities.xml | yq '.domainCapabilities.cpu.mode.[].model.[] | select(.+@usable=="yes").+content'))
  local supported_models=""
  for usable_model in "${usable_models[@]}"; do
    local obsolete="false"
    for obsolete_cpu in "${!obsolete_cpu_models[@]}"; do
      if [ "${usable_model}" = "${obsolete_cpu}" ]; then
        obsolete="true"
      fi
    done

    if [ "${obsolete}" = "false" ]; then
      if [ -z "${supported_models}" ]; then
        supported_models="${usable_model}"
      else
        supported_models="${supported_models} ${usable_model}"
      fi
    fi
  done
  echo "${supported_models}"
}

# see https://github.com/kubevirt/kubevirt/blob/ef9e136df7e676b408fb8b38dffbdf91be491601/pkg/virt-handler/node-labeller/cpu_plugin.go#L142-L161
function get_supported_features() {
  out_path="$1"
  local required_features=$(yq -oy ${out_path}/supported_features.xml | yq '.cpu.feature.[] | select(.+@policy == "require").+@name')
  echo "${required_features}"
}

function get_virsh_meta() {
  out_path="$1"
  local virsh_meta=$(cat ${out_path}/.version)
  echo "${virsh_meta}"
}

echo "‚öôÔ∏è discovering host and domain cpu capabilities..."
cpu_caps
report
tarball
